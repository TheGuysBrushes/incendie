07/06
###################################	#
#	foret.cpp		#
# tryLoadEssence (utilisait explode)	#
# Chargement du fichier texte d'essences#
###################################	#

vector< string >& Foret::explode(const string& str)
{
	istringstream split(str);
	vector< string >* tokens = new vector<string>;
	
	for(string each; getline(split, each, ' '); tokens->push_back( each.c_str()) );
	
	#if DEBUG_FILE
	cout << "vecteur : \t";
	for (vector<string>::const_iterator i(tokens->begin()); i!= tokens->end(); ++i){
		cout << *i<< "|";
	}
	cout << endl;
	#endif

	return *tokens;
}

// 	ifstream f (fileName.c_str());
// 	#if DEBUG_FILE
// 	cout<< "fichier ouvert?" <<endl;
// 	#endif
// 	if(f){
// 		#if DEBUG_FILE
// 		cout <<"oui"<< endl;
// 		#endif
// 		
// 		string line;
// 		
// 		int indice = 0;
// 		while(getline(f,line)){
// 			#if DEBUG_FILE
// 			cout << endl<< "ligne : \t"<< line<< endl;
// 			#endif
// 			
// 			vector<string>& tokens = explode(line);	
// 			
// 			// remplacement des underscores par des espaces
// 			if ( tokens[0].find('_')!= string::npos ){
// 				int ind= tokens[0].find('_');
// 				#if DEBUG_FILE
// 				cout << "ind de _ : "<< ind<< endl;
// 				#endif
// 				
// 				tokens[0][ind]= ' ';
// 			}
// 			
// 			// conversion du diametre en float
// 			float diam; istringstream(tokens[2])>> diam;
// 			float	haut;	istringstream(tokens[3])>> haut;
// 			essences.push_back( Essence(indice, tokens[0],
// 											atoi(tokens[1].c_str()),
// 											diam,
// 											haut,
// 											atoi(tokens[4].c_str()),
// 											atoi(tokens[5].c_str())		) );
// 			
// 			indice +=1;
// 			// suppression du vecteur de strings instancié en pointeur
// 			delete &tokens;
// 		}
// 		#if DEBUG_FILE
// 		showEssences();
// 		#endif
// 		
// 		return true;
// 	}
// 	else {
// 		#if DEBUG_FILE
// 		cout << "non" <<endl;
// 		#endif
// 		return false;
// 	}

07/06
###################################	#
#	firewidget.cpp		#
#	loadForest			#
###################################	#
.h:
	bool loadForest(std::string filename);

/**
 * Charge une foret à partir d'un nom de fichier, la foret est déja instanciée
 * @author Ugo et Florian
 * @deprecated
 */
bool FireWidget::loadForest(std::string filename)
{	
	ifstream* file = new ifstream(filename.c_str(), std::ios::in|std::ios::binary);

	if (!file->is_open()){
		std::cout<< "Echec ouverture fichier de sauvegarde"<< std::endl;
		return false;
	}
	else {
		// Réinitialisation des tailles de la matrice...
		forest->loadSizes(file);
		// ... puis chargement de la nouvelle matrice
		forest->load(file,NULL);
		return true;
		
	}
}

28/05
###################################	#
#				firescreen.cpp				#
#	initForest(choix crea foret)		#
###################################	#
/**
 * Restaure une forêt à partir d'un fichier ouvert
 * @author Florian
 * @param file fichier binaire ouvert contenant la sauvegarde de la forêt (taille-essences-arbres)
 */
// void FireScreen::createForest(ifstream* file)
// {
// 	int largeur, hauteur;
// 	file->read( (char *)&(largeur), sizeof(int));
// 	file->read( (char *)&(hauteur), sizeof(int));
// 	
// 	createForest(largeur, hauteur, file);
// }

/**
 * Crée une nouvelle forêt à partir d'une fenêtre de paramétrage
 * @author Florian
 * @param fwel fenêtre qui a été appelée et contient les paramètres de la nouvelle forêt
 */
// void FireScreen::initForest(Fwelcome * fwel)
// {
// 	nb_tour = 0;
// 	int largeur= fwel->get_larg();
// 	int hauteur= fwel->get_haut();
// 	ifstream* file= fwel->getFile();
// 	QImage* picture= fwel->getImage();	
// 	
// 	// Choix de la méthode de création de foret selon les paramètres initialisés
// 	if ( !fWidget->initialise(largeur,hauteur, file) ){ // Essai création par fichier de sauvegarde si il est ouvert
// 		
// 		// sinon essai creation par image, si elle est chargée
// 		if ( !fWidget->initialise(largeur,hauteur, picture) ){ // 
// 			// Sinon, cas par défaut : Creation selon les paramétres de la fenetre de paramétrage
// 			fWidget->initialise(largeur,hauteur,
// 									fwel->get_proba(),
// 									fwel->get_coef()	);
// 		}
// 		
// 		majCompteur();
// 	}
// 	
// 	initSizes(largeur, hauteur);
// }


22/05
###############################	#
#			firewidget					#
# constructeur avec crea foret	#
###############################	#
.h :
// 	FireWidget(int _largeur, int _hauteur, float proba = 0.60, float coef_brulure=1.0);

.cpp :
/**
 * Constructeur de classe. Initialise les différents pointeurs
 * et fixe la taille minimale du widget
 * @param int _largeur : nombre de colonnes de la matrice 
 * @param int _hauteur : nombre de lignes de la matrice
 * @param float _proba : probabilité qu'une cellule deviennent un arbre
 * @param float _coef : coefficient de combustion de l'incendie
 * @author Ugo et Florian
 * @deprecated
 */
// FireWidget::FireWidget(int _largeur, int _hauteur, float proba, float coef_brulure): QWidget()
// {
// 	buffer = new QImage();
// 	color = new QColor(Qt::black);
// 	bufferPainter= new QPainter(); 	
// 	pictureForest= new QImage();
// 
// 	initialise(_largeur, _hauteur, proba, coef_brulure);
// // 	loadFromPicture("../foret_pay.tif");
// 	
// 	rubber = NULL;
// }


22/04
###############################	#
#			firewidget.cpp				#
#	drawForest/Variable();			#
###############################	#
/**
 * IMPROVEIT
 * J'ai essayé de créer une fonction qui dessinerai les cellules grâce à l'appel d'une autre fonction donné en paramètre,
 * 	mais "function/std::function/function::function avec #include <functional> ne marche pas
 * @deprecated
 * @author Florian
 */

/**
 * premiere fonction, il aurait fallu créer drawStatic ...
 */
// void FireWidget::drawVariable(int posWidth, int posHeight, const Cellule* cell)
// {
// 	int cell_larg = width() / this->foret.largeur();
// 	int cell_haut = height() / this->foret.hauteur();
// 	
// 	QPainter paint(this->buffer);
// 	
// 	if( cell->getEtat() == 0){
// 		this->color->setNamedColor("black");
// 		
// 	}else if(cell->getEtat() == 1){
// 		// Il faut ici vérifier l'essence de l'arbre pour lui attribuer une variante de vert
// 		unsigned indice= dynamic_cast < const Arbre* >(cell)->getEssence()->getIndice();
// 		setColor(indice);
// 	}
// 	paint.fillRect(posWidth, posHeight, cell_larg, cell_haut, *(color));	
// }


// void FireWidget::drawForest(void(*pDraw)(int, int, const Cellule*) )
// {
// 	int cell_larg = width() / this->foret.largeur();
// 	int cell_haut = height() / this->foret.hauteur();
// 	
// 	int current_largeur= 0;
// 	for(int i=0; i<this->foret.largeur(); ++i){
// 		// On ne passe pas la hauteur de la grille mais le nombre de colonne*taille de colonne pour
// 		// éviter la petite zone en bas de grille
// 		vector< Cellule* >* ligne= foret[i];
// 		
// 		int current_hauteur= 0;
// 		for( vector< Cellule* >::const_iterator j( ligne->begin() ); j!=ligne->end(); ++j){
// 			Cellule* cell= *j;
// 
// 			pDraw(cell_larg,cell_haut, cell);
// 			
// 	// Incrémentations des positions des cellules
// 			current_hauteur += cell_haut;
// 		}
// 		current_largeur += cell_larg;
//     }
// }

22/04
################################
#			firewidget.h			#
#	drawForest/Variable();		#
################################
	// 	void drawVariable(int posWidth, int posHeight, const Cellule* cell);
	// 	void drawForest(void(*pDraw)(int, int, const Cellule*) );
	// 	void drawForest(void* drawCell(int, int, const Cellule*));
	// 	void drawForest(std::function<void(void)> drawCell );
	

################################
#			foret.cpp			#
#			explode()			#
#		avec const char*		#
################################

vector< const char* >& explode(const string& str)
{
	istringstream split(str);
	vector< const char* >* tokens = new vector<const char*>;
	
	for(string each; getline(split, each, ' '); tokens->push_back(each.c_str()) );
	
	#if DEBUG_FILE
	for (vector<const char*>::const_iterator i(tokens->begin()); i!= tokens->end(); ++i){
		cout << *i<< " - ";
	}
	cout << endl;
	#endif

	return   *tokens;
}

################################
#			foret.cpp			#
#			adjacents()			#
################################
// 	if (col<colonnes-1) {
// 		Cellule* cell= matrice[row][col+1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 		
// 	if (col>0) {
// 		Cellule* cell= matrice[row][col-1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 	
// 	if (row<lignes-1) {
// 		Cellule* cell= matrice[row+1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 
// 	if (row>0) {
// 		Cellule* cell= matrice[row-1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}

################################
#			foret.cpp			#
#			NextMove()			#
################################
après bool modif = false;
// 		for_each<Cellule>(matrice[i].begin(), matrice[i].end(), transition);

################################
#			foret.h/cpp			#
#			eteindre();			#
################################

void Foret::eteindre(int row, int col){
	dynamic_cast < Arbre* >(matrice[row][col])->blast();
}
