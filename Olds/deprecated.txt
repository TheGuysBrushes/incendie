
################################
#			foret.cpp			#
#			explode()			#
#	avec const char*			#

vector< const char* >& explode(const string& str)
{
	istringstream split(str);
	vector< const char* >* tokens = new vector<const char*>;
	
	for(string each; getline(split, each, ' '); tokens->push_back(each.c_str()) );
	
	#if DEBUG_FILE
	for (vector<const char*>::const_iterator i(tokens->begin()); i!= tokens->end(); ++i){
		cout << *i<< " - ";
	}
	cout << endl;
	#endif

	return   *tokens;
}

################################
#		loadEssences()			#
#	const char* et atof		#
			vector<const char*>& tokens = explode(line);	
			essences.push_back( Essence(indice,
												tokens[0], atoi(tokens[1]/*.c_str()*/),
												atof(tokens[2]/*, NULL*/),
												atoi(tokens[3]/*.c_str()*/),
												atoi(tokens[4]/*.c_str()*/),
												atoi(tokens[5]/*.c_str()*/)			)		);
			#if DEBUG_FILE
			cout << "diam : " << atof(tokens[2]/*.c_str()*//*, NULL*/)<< endl;
			#endif

################################			
################################
		

################################
#			foret.cpp			#
#			adjacents()			#
################################
// 	if (col<colonnes-1) {
// 		Cellule* cell= matrice[row][col+1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 		
// 	if (col>0) {
// 		Cellule* cell= matrice[row][col-1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 	
// 	if (row<lignes-1) {
// 		Cellule* cell= matrice[row+1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 
// 	if (row>0) {
// 		Cellule* cell= matrice[row-1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}

################################
#			foret.cpp			#
#			NextMove()			#
################################
apr√®s bool modif = false;
// 		for_each<Cellule>(matrice[i].begin(), matrice[i].end(), transition);

################################
#			foret.h				#
#			public:				#
################################
// 	void eteindre(Arbre* ab);	// TODO
// void eteindre(int row, int col)

################################
#			foret.cpp			#
#			eteindre();			#
################################
// void Foret::eteindre(int row, int col)
// {
// 	dynamic_cast < Arbre* >(matrice[row][col])->blast();
// // 	onFire.remove_if<Cellule>();
// }
