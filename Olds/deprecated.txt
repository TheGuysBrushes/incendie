04/05
################################
#			firewidget.cpp			#
#				newForet()			#
################################
// void FireWidget::newForet(int _largeur, int _hauteur, float _proba, float _coef_brulure)
// {
	// 	delete(foret);
	// 	foret = new Foret(_largeur,_hauteur, _proba, _coef_brulure);
	// }


22/04
################################
#			firewidget.cpp			#
#	drawForest/Variable();		#
################################
/**
 * IMPROVEIT
 * J'ai essayé de créer une fonction qui dessinerai les cellules grâce à l'appel d'une autre fonction donné en paramètre,
 * 	mais "function/std::function/function::function avec #include <functional> ne marche pas
 * @deprecated
 * @author Florian
 */

/**
 * premiere fonction, il aurait fallu créer drawStatic ...
 */
// void FireWidget::drawVariable(int posWidth, int posHeight, const Cellule* cell)
// {
// 	int cell_larg = width() / this->foret.largeur();
// 	int cell_haut = height() / this->foret.hauteur();
// 	
// 	QPainter paint(this->buffer);
// 	
// 	if( cell->getEtat() == 0){
// 		this->color->setNamedColor("black");
// 		
// 	}else if(cell->getEtat() == 1){
// 		// Il faut ici vérifier l'essence de l'arbre pour lui attribuer une variante de vert
// 		unsigned indice= dynamic_cast < const Arbre* >(cell)->getEssence()->getIndice();
// 		setColor(indice);
// 	}
// 	paint.fillRect(posWidth, posHeight, cell_larg, cell_haut, *(color));	
// }


// void FireWidget::drawForest(void(*pDraw)(int, int, const Cellule*) )
// {
// 	int cell_larg = width() / this->foret.largeur();
// 	int cell_haut = height() / this->foret.hauteur();
// 	
// 	int current_largeur= 0;
// 	for(int i=0; i<this->foret.largeur(); ++i){
// 		// On ne passe pas la hauteur de la grille mais le nombre de colonne*taille de colonne pour
// 		// éviter la petite zone en bas de grille
// 		vector< Cellule* >* ligne= foret[i];
// 		
// 		int current_hauteur= 0;
// 		for( vector< Cellule* >::const_iterator j( ligne->begin() ); j!=ligne->end(); ++j){
// 			Cellule* cell= *j;
// 
// 			pDraw(cell_larg,cell_haut, cell);
// 			
// 	// Incrémentations des positions des cellules
// 			current_hauteur += cell_haut;
// 		}
// 		current_largeur += cell_larg;
//     }
// }

22/04
################################
#			firewidget.h			#
#	drawForest/Variable();		#
################################
	// 	void drawVariable(int posWidth, int posHeight, const Cellule* cell);
	// 	void drawForest(void(*pDraw)(int, int, const Cellule*) );
	// 	void drawForest(void* drawCell(int, int, const Cellule*));
	// 	void drawForest(std::function<void(void)> drawCell );
	

################################
#			foret.cpp			#
#			explode()			#
#	avec const char*			#
################################

vector< const char* >& explode(const string& str)
{
	istringstream split(str);
	vector< const char* >* tokens = new vector<const char*>;
	
	for(string each; getline(split, each, ' '); tokens->push_back(each.c_str()) );
	
	#if DEBUG_FILE
	for (vector<const char*>::const_iterator i(tokens->begin()); i!= tokens->end(); ++i){
		cout << *i<< " - ";
	}
	cout << endl;
	#endif

	return   *tokens;
}

################################
#			foret.cpp			#
#			adjacents()			#
################################
// 	if (col<colonnes-1) {
// 		Cellule* cell= matrice[row][col+1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 		
// 	if (col>0) {
// 		Cellule* cell= matrice[row][col-1];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 	
// 	if (row<lignes-1) {
// 		Cellule* cell= matrice[row+1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}
// 
// 	if (row>0) {
// 		Cellule* cell= matrice[row-1][col];
// 		// verification que la cellule est un arbre, qui n'est pas enflammee
// 		if (cell->getEtat()==1)
// 			liste.push_back( dynamic_cast < Arbre* >(cell) );
// 	}

################################
#			foret.cpp			#
#			NextMove()			#
################################
après bool modif = false;
// 		for_each<Cellule>(matrice[i].begin(), matrice[i].end(), transition);

################################
#			foret.h/cpp			#
#			eteindre();			#
################################

void Foret::eteindre(int row, int col){
	dynamic_cast < Arbre* >(matrice[row][col])->blast();
}


################################
#			foret.h/cpp			#
#			drawFire();			#
################################
/**
 * Dessine la matrice dans le buffer, sur l'ancienne matrice
 * 	On réutilise les cellules non susceptibles d'avoir été modifiées
 * @author Ugo and Florian
 */
void FireWidget::drawFire()
{
	#if DEBUG_TMATRICE
	cout <<"draw fire "<< endl;
	#endif
	
	QPainter paint(this->buffer);
	
	int current_hauteur= 0;
	for(int i=0; i<foret->hauteur(); ++i){
		// On ne passe pas la hauteur de la grille mais le nombre de colonne*taille de colonne pour
		// éviter la petite zone en bas de grille
		vector< Cellule* >* ligne= foret->operator[](i);
		
		int current_largeur= 0;
		for( vector< Cellule* >::const_iterator j( ligne->begin() ); j!=ligne->end(); ++j){
			Cellule* cell= *j;

			if(cell->getEtat() == 2){
				this->color->setNamedColor("red");
				paint.fillRect(current_largeur, current_hauteur, tailleCell, tailleCell, *(color));
				
			}else if(cell->getEtat() ==3){
				this->color->setNamedColor("gray");
				paint.fillRect(current_largeur, current_hauteur, tailleCell, tailleCell, *(color));
			}

			#if DEBUG_TMATRICE
			cout <<"draw arbre feu ; ";
			#endif

			// Incrémentations des positions des cellules
			current_largeur += tailleCell;
		}
		#if DEBUG_TMATRICE
		cout << endl;
		#endif
		current_hauteur+= tailleCell;
	}
	
	#if DEBUG_TMATRICE
	cout <<"fin draw fire" <<  endl;
	#endif
}
